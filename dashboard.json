{
  "metadata": {
    "totalProblems": 2,
    "lastUpdated": "2025-09-02T11:35:55.107Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 2,
        "Easy": 1,
        "Medium": 0,
        "Hard": 1
      },
      "Hackerrank": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "leetcode-easy-two-sum",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Two Sum",
      "language": "cpp",
      "files": {
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int> &nums, int target) {\n        unordered_map<int, int> hash;\n        for (int i = 0; i < nums.size(); i++) {\n            hash[nums[i]] = i;\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (hash.find(complement) != hash.end() && hash[complement] != i) {\n                return {i, hash[complement]};\n            }\n        }\n        // If no valid pair is found, return an empty vector\n        return {};\n    }\n};",
        "readme": "ArrayHashTable\n\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\tOnly one valid answer exists.\n\n\n \nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
        "notes": "Two Sum\n\n          - Summary: This algorithm utilizes an unordered map (hash table) to efficiently find pairs of numbers that sum to a target value.  It first populates the hash table with each number in the input array and its index. Then, it iterates through the array again; for each number, it checks if the complement (target - number) exists in the hash table. If the complement is found and its index differs from the current number's index, it returns the indices of the pair. Otherwise, it continues until a pair is found or the array is exhausted.\n\n          - Time Complexity: O(n) because the algorithm involves two iterations through the input array of size n. Hash table operations (insertion and lookup) take constant time on average.\n          - Space Complexity: O(n) because the space used by the unordered map is proportional to the number of elements in the input array."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-09-02T11:22:59.000Z"
    },
    {
      "id": "leetcode-hard-median-of-two-sorted-arrays",
      "platform": "Leetcode",
      "difficulty": "Hard",
      "problemName": "Median of Two Sorted Arrays",
      "language": "cpp",
      "files": {
        "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Get the sizes of both input arrays.\n        int n = nums1.size();\n        int m = nums2.size();\n\n        // Merge the arrays into a single sorted array.\n        vector<int> merged;\n        for (int i = 0; i < n; i++) {\n            merged.push_back(nums1[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            merged.push_back(nums2[i]);\n        }\n\n        // Sort the merged array.\n        sort(merged.begin(), merged.end());\n\n        // Calculate the total number of elements in the merged array.\n        int total = merged.size();\n\n        if (total % 2 == 1) {\n            // If the total number of elements is odd, return the middle element as the median.\n            return static_cast<double>(merged[total / 2]);\n        } else {\n            // If the total number of elements is even, calculate the average of the two middle elements as the median.\n            int middle1 = merged[total / 2 - 1];\n            int middle2 = merged[total / 2];\n            return (static_cast<double>(middle1) + static_cast<double>(middle2)) / 2.0;\n        }\n    }\n};",
        "readme": "ArrayBinarySearchDivideandConquer\n\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \nConstraints:\n\n\n\tnums1.length == m\n\tnums2.length == n\n\t0 <= m <= 1000\n\t0 <= n <= 1000\n\t1 <= m + n <= 2000\n\t-106 <= nums1[i], nums2[i] <= 106",
        "notes": "Median of Two Sorted Arrays\n\n          - Summary: The code uses vectors (dynamic arrays) to store and manipulate input and merged arrays. It first merges two sorted input vectors into a single vector. Then, it sorts the merged vector and determines the median based on whether the total number of elements is even or odd. If odd, the middle element is the median; if even, the average of the two middle elements is the median.\n\n          - Time Complexity: O(m+n+k log k), where m and n are the lengths of the input arrays and k = m+n. The merging of arrays takes O(m+n), sorting takes O(k log k), and other operations are O(1).  The dominant factor is the sorting step. If the input arrays are already sorted, the merging step would be O(m+n), and we can avoid the sort, resulting in overall O(m+n).\n          - Space Complexity: O(m+n), as a new vector of size m+n is created to store the merged array.  The space used is linear with respect to the total input size."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-09-02T11:35:40.000Z"
    }
  ]
}